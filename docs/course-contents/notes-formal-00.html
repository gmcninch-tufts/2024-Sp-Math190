<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Math190-Tufts University - Overview on Formalization</title>
	<script>
	  window.MathJax = {
	    options: {
	      ignoreHtmlClass: 'tex2jax_ignore',
	      processHtmlClass: 'tex2jax_process'
	    },
	    tex: {
	      autoload: {
		color: [],
		colorv2: ['color']
	      },
	      packages: {'[+]': ['noerrors']}
	    },
	    loader: {
	      load: ['input/asciimath', '[tex]/noerrors']
	    }
	  };
	</script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script"></script>
        <link rel="stylesheet" href="../css/default.css" />
	<link rel="stylesheet" href="../css/haddock.css" />
	
	<link href="https://fonts.googleapis.com/css?family=Lato:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Arimo:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Roboto:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" type="text/css" rel="stylesheet" media="screen" />
	<link href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" type="text/css" rel="stylesheet" media="screen" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous" />			
    </head>
    <body>
        <header>
          <div class="logo">
            <a href="../">
	      Math190 - Spring 2024 - Tufts Univ</a>
          </div>
          <nav>
            <a href="../about.html">About</a>
	    <a href="../course-pages/Math190--course-info.html">Info</a>	    
            <a href="../archive.html">Archive</a>
          </nav>
        </header>

        <main role="main">
            <h1>Overview on Formalization</h1>
            <article>
    <section class="header">
        Posted on 2024-03-25
        
    </section>
    <section>
        <h1 id="proof-assistants">Proof assistants</h1>
<h2 id="foundations-of-mathematics-in-proof-assistants">Foundations of mathematics in proof assistants</h2>
<p>Quoting from an answer by <a href="https://proofassistants.stackexchange.com/questions/866/which-proof-assistant-would-you-advise-me-to-learn-in-2022-considering-my-inte/884#884">Jason Rute on the proofassistants.stackexchange</a></p>
<blockquote>
<p>Foundations of mathematics can mean a lot of things to a lot of
people. Proof assistants present a sort of practical foundations of
mathematics, where one actually comes up with a usable set of rules
and axioms for doing mathematics formally in practice. Mizar and
Metamath (set.mm) use a set theory foundation which is more similar
to how foundations is taught in a typical university logic
course. HOL-Light, HOL4, and Isabelle/HOL use higher order logic,
which is a simpler type theory. And as we already mentioned Lean,
Coq, and Agda use dependent type theory.</p>
</blockquote>
<p>Here <em>type theory</em> is a system of logic that can be used as the <em>foundations of mathematics</em>.
The objects discussed are <em>terms</em>, and every term has a <em>type</em>.</p>
<p>A <strong>dependent type</strong> is a <em>type</em> whose definition depends on a value;
see e.g. the wikipedia discussion of <a href="https://en.wikipedia.org/wiki/Dependent_type">dependent type
theory</a>.</p>
<p>In simple type theory, for example, there is a type <code>Nat</code>, or
<span class="math inline">\(\mathbb{N}\)</span>, of natural numbers. And there are <em>parametrized types</em>;
e.g. <code>List Nat</code> is the type of <em>lists</em> of natural numbers.</p>
<p>So e.g. the notation</p>
<pre><code>[1, 3, 5, 7] : List Nat</code></pre>
<p>means that the indicated list <code>[1,3,5,7]</code> is a term of type <code>List Nat</code>.</p>
<p>Now we can give perhaps the most basic example of a <em>dependent type</em>:
the type of vectors of a given fixed length; e.g. <code>Vect m Nat</code> is the type
of vectors of natural numbers of length <code>m : Nat</code></p>
<p>So for example</p>
<pre><code>[1,3,5] : Vect 3 Nat</code></pre>
<p>Observe that the type <code>Vect m Nat</code> <em>depends</em> on the term <code>m : Nat</code>.</p>
<p>Another example of a <em>dependent type</em> is the type of <em>equality</em>
between natural numbers. For <code>n m : Nat</code>, there is a type <code>n = m</code>. This type has <em>no</em> terms if <code>n</code> and <code>m</code> are not the same natural
number, and it has a unique term <code>rfl : n = m</code> (here <code>rfl</code> represents
the “reflexive property”).</p>
<p>This is an extremely quick summary; the point is that dependent types
give one an ability to express mathematical statements and proofs,
more-or-less as we already think about such expressions and proofs.</p>
<p>Resources:</p>
<ul>
<li><p><a href="https://proofassistants.stackexchange.com/">‘stack exchange’ for proof assistants</a></p></li>
<li><p><a href="https://proofassistants.stackexchange.com/questions/43/proof-assistants-for-beginners-a-comparison">e.g. this post comparing proof assistants</a></p></li>
</ul>
<h2 id="list-of-proof-assistants">List of Proof Assistants</h2>
<ul>
<li><p><a href="https://coq.inria.fr/">The Coq Proof Assistant</a></p></li>
<li><p><a href="https://wiki.portal.chalmers.se/agda/Main/HomePage">Agda</a></p></li>
<li><p><a href="https://leanprover-community.github.io/">LEAN-prover community</a></p></li>
<li><p><a href="https://isabelle.in.tum.de/">Isabelle/HOL</a></p></li>
</ul>
<h2 id="audience">“audience”</h2>
<p>There are a variety of users of proof assistants, mainly (I think) in
two categories (the boundary between which can be blurry):</p>
<ul>
<li><p>theoretical computer science</p></li>
<li><p>mathematics</p></li>
</ul>
<p>The pure mathematical point of view I’d like to discuss is that taken
by the <a href="https://xenaproject.wordpress.com/what-is-the-xena-project/">Xena project</a>.</p>
<p>There has been a good bit of energy aimed at formalizing the sort of
mathematics that “pure mathematicians in mathematics departments” are
familiar witth.</p>
<p>A substantial output from this activity is a library of formalized mathematics in Lean:
<a href="https://github.com/leanprover-community/mathlib4">mathlib</a></p>
<h2 id="some-successes-of-proof-assistants">Some successes of proof assistants</h2>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Four_color_theorem">Four-color Theorem</a></p>
<p>The four color theorem states that no more than four colors are
required to color regions of a map so that two adjacent
regions never have the same color.</p>
<p>(from Wikipedia:)</p>
<blockquote>
<p>“Kenneth Appel and Wolfgang Haken at the University of Illinois
announced, on June 21, 1976,[16] that they had proved the theorem.”</p>
</blockquote>
<p>Subsequently, there were some errors discovered and then corrected
in this algorithmic proof.</p>
<blockquote>
<p>“In 2005, Benjamin Werner and Georges Gonthier formalized a proof
of the theorem inside the Coq proof assistant. This removed the
need to trust the various computer programs used to verify
particular cases; it is only necessary to trust the Coq
kernel.”</p>
</blockquote>
<p><a href="https://www.cl.cam.ac.uk/~lp15/Pages/4colproof.pdf">Gonthier et al report</a><br />
<a href="https://www.ams.org/notices/200811/tx081101382p.pdf">Formal Proof—The Four- Color Theorem - Gonthier</a></p>
<p>Quoting from the introduction to Gonthier’s article in the <em>Notices</em>:</p>
<blockquote>
<p>“Even Appel and Haken’s 1976 triumph [2] had a hint of defeat:
they’d had a computer do the proof for them! Perhaps the
mathematical controversy around the proof died down with their
book [3] and with the elegant 1995 revision [13] by Robertson,
Saunders, Seymour, and Thomas. However something was still amiss:
both proofs combined a textual argument, which could reasonably be
checked by inspection, with computer code that could not. Worse,
the empirical evidence provided by running code several times with
the same input is weak, as it is blind to the most common cause of
“computer” error: programmer error.”</p>
</blockquote>
<blockquote>
<p>…</p>
</blockquote>
<blockquote>
<p>“For some thirty years, computer science has been working out a
solution to this problem: formal program proofs. The idea is to
write code that describes not only what the machine should do, but
also why it should be doing it—a formal proof of correctness. The
validity of the proof is an objective mathematical fact that can
be checked by a different program, whose own validity can be
ascertained empirically because it does run on many inputs.</p>
</blockquote></li>
<li><p><a href="https://en.wikipedia.org/wiki/Feit%E2%80%93Thompson_theorem">Feit-Thompson’s odd-order Theorem</a>
odd-order theorem</p>
<p>Wikipedia summary:</p>
<blockquote>
<p>“William Burnside (1911, p. 503 note M) conjectured that every
nonabelian finite simple group has even order. Richard Brauer (1957)
suggested using the centralizers of involutions of simple
groups as the basis for the classification of finite simple
groups, as the Brauer–Fowler theorem shows that there are only a
finite number of finite simple groups with given centralizer of an
involution. A group of odd order has no involutions, so to carry
out Brauer’s program it is first necessary to show that non-cyclic
finite simple groups never have odd order. This is equivalent to
showing that odd order groups are solvable, which is what Feit and
Thompson proved.”</p>
</blockquote>
<p>A group of authors – Georges Gonthier, Andrea Asperti, Jeremy
Avigad, Yves Bertot, Cyril Cohen, François Garillot, Stéphane Le
Roux, Assia Mahboubi, Russell O’Connor, Sidi Ould Biha, Ioana Pasca,
Laurence Rideau, Alexey Solovyev, Enrico Tassi and Laurent Théry –
formalized this proof in the Coq proof assistant – see <a href="https://www.cs.unibo.it/~asperti/PAPERS/odd_order.pdf">A
Machine-Checked Proof of the Odd Order
Theorem</a>.</p></li>
<li><p>Kepler conjecture</p>
<p>From the <a href="https://en.wikipedia.org/wiki/Kepler_conjecture">Wikipedia summary</a>:</p>
<blockquote>
<p>The Kepler conjecture, named after the 17th-century mathematician
and astronomer Johannes Kepler, is a mathematical theorem about
sphere packing in three-dimensional Euclidean space. It states
that no arrangement of equally sized spheres filling space has a
greater average density than that of the cubic close packing
(face-centered cubic) and hexagonal close packing
arrangements. The density of these arrangements is around 74.05%.</p>
</blockquote>
<p>Proof by T. Hales:</p>
<blockquote>
<p>In 1998, Thomas Hales, following an approach suggested by Fejes
Tóth (1953), announced that he had a proof of the Kepler
conjecture. Hales’ proof is a proof by exhaustion involving the
checking of many individual cases using complex computer
calculations. Referees said that they were “99% certain” of the
correctness of Hales’ proof, and the Kepler conjecture was
accepted as a theorem. In 2014, the Flyspeck project team, headed
by Hales, announced the completion of a formal proof of the Kepler
conjecture using a combination of the Isabelle and HOL Light proof
assistants. In 2017, the formal proof was accepted by the journal
Forum of Mathematics, Pi.[1]</p>
</blockquote>
<p><a href="https://doi.org/10.1017%2Ffmp.2017.1">publication</a></p></li>
<li><p>some modern algebraic geometry</p>
<p>some “early work” formalizing parts of the Stacks Project (of <a href="https://stacks.math.columbia.edu/">Johan
de Jong</a> et al) can be found her</p>
<p><a href="https://github.com/kbuzzard/lean-stacks-project">https://github.com/kbuzzard/lean-stacks-project</a>.</p>
<p>The author of that project write (in the <code>README</code> in that repo):</p>
<blockquote>
<p>This project is deprecated. It was joint work by me (Kevin
Buzzard), Kenny Lau and Chris Hughes. It was our first attempt to
do MSc level mathematics in Lean (back in 2017/18) and we made
some poor design decisions due to inexperience. Once I had
understood better how to write this project, I supervised Ramon
Fernandez Mir’s masters project which achieved everything this
repo achieved and more too, and better. I would look there
instead.</p>
</blockquote>
<p>Raymon Fernandez Mir - an undergraduate student of Kevin Buzzard
formalized the notion - due to A. Grothendieck - of a <em>scheme</em> in
algebraic geometry.</p>
<p>From the introduction to his project:</p>
<blockquote>
<p>The starting point of this project is the work done by Kevin
Buzzard, Chris Hughes and Kenny Lau on formally verifying parts of
The Stacks Project [1].</p>
</blockquote>
<blockquote>
<p>…</p>
</blockquote>
<blockquote>
<p>the objective of this project is to,
starting from scratch, define a scheme in Lean.</p>
</blockquote>
<p>A summary can be found in <a href="https://www.imperial.ac.uk/media/imperial-college/faculty-of-engineering/computing/public/1819-ug-projects/Fernandez-I-MirR-Schemes-in-Lean.pdf">this project report</a></p>
<p>The code can be found in <a href="https://github.com/ramonfmir/lean-scheme/">this repository</a></p>
<p><strong>perfectoid spaces</strong></p>
<p>Kevin Buzzard, Johan Commelin, and Patrick Massot formalized Peter
Scholze’s definition of <strong>perfectoid spaces</strong> (see Scholze’s paper
<a href="https://arxiv.org/abs/1709.07343">“Étale cohomology of diamonds”</a>)</p>
<p>The code comprisingt he formalization is here:
<a href="https://leanprover-community.github.io/lean-perfectoid-spaces/">https://leanprover-community.github.io/lean-perfectoid-spaces/</a></p>
<p>See also the blog post at the xenaproject:
<a href="https://xenaproject.wordpress.com/2019/05/11/perfectoid-spaces/">https://xenaproject.wordpress.com/2019/05/11/perfectoid-spaces/</a> and the page</p>
<p>There is a useful “how to read this document” page here:
<a href="https://leanprover-community.github.io/lean-perfectoid-spaces/how-to-read-lean.html">https://leanprover-community.github.io/lean-perfectoid-spaces/how-to-read-lean.html</a></p></li>
<li><p>Terence Tao [2023-10-23]
<a href="https://mathstodon.xyz/@tao/111287749336059662">LEAN helped catch a error in some recent work</a></p>
<iframe src="https://mathstodon.xyz/@tao/111287749336059662/embed" class="mastodon-embed" style="max-width: 100%; border: 0" width="400" allowfullscreen="allowfullscreen">
</iframe>
<script src="https://mathstodon.xyz/embed.js" async="async"></script></li>
<li><p>going forward: Fermat’s Last Theorem</p>
<ul>
<li><p>Kevin Buzzard <a href="https://xenaproject.wordpress.com/2024/01/20/lean-in-2024/">reports
here</a>
that he has been awarded a grant by the EPSRC to formalize (parts of?) the proof
of Fermat’s Last Theorem in Lean.</p></li>
<li><p>(an earlier talk of Buzzard described <a href="https://www.ma.imperial.ac.uk/~buzzard/xena/pdfs/AITP_2022_FLT_talk.pdf">some of the requirements of
this
task</a></p></li>
</ul></li>
<li><p>Buzzard’s <a href="https://www.youtube.com/watch?v=SEID4XYFN7o">talk at 2022 ICM</a></p></li>
</ul>
    </section>
</article>

        </main>

        <footer>
	  <nav>
	    <a href="http://www.tufts.edu">
	      <i class="fas fa-chalkboard"></i>
	      Tufts
	    </a>	    
	    <a href="http://math.tufts.edu">
	      <i class="fas fa-chalkboard-teacher"></i>
	      Tufts Math
	    </a>
	    <a href="https://gmcninch-tufts.github.io/math">
	      <i class="fas fa-coffee"></i>
	      G McNinch
	    </a>
	    <a href="https://github.com/gmcninch-tufts">
	      <i class="fab fa-github"></i>
	      GitHub
	    </a>	    
	  </nav>
        </footer>
    </body>
</html>
